# <img src="https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExbnluOG4xdGlpeWxwYnFhM3Bjc2Z3dzN5eDhhaThza2N0Ym9wOGUxOCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/zECASgodRMZ5QAbRao/giphy.gif" width="30px">Вопросы: Неделя 4!<img src="https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExbnluOG4xdGlpeWxwYnFhM3Bjc2Z3dzN5eDhhaThza2N0Ym9wOGUxOCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/zECASgodRMZ5QAbRao/giphy.gif" width="30px">
# Содержание
- [Android](#android)
- [Concurrency](#concurrency)
   - [Q1a](#q1a) Какие проблемы может решить многопоточность?
   - [Q2a](#q2a) Какой из этих компонентов не обязательно регистрировать в файле AndroidManifest и почему?
   - [Q3a](#q3a) Расскажите про AndroidManifest и для чего он нужен?
   - [Q4a](#q4a) Что происходит между тем как ты нажал на иконку приложения и его запуском?
     
     ## Activity
   - [Q5a](#q5a) Что такое Activity?
   - [Q6a](#q6a) Как стартует первая Activity?
   - [Q7a](#q7a) Как можно переключаться между Activity? Первый способ с помощью Intent-ов.
   - [Q8a](#q8a) Второй способ с помощью putExtra().
   - [Q9a](#q9a) Опишите жизненный цикл Activity.
   - [Q10a](#q10a) Что происходит при перевороте экрана Activity? Какие методы вызываются? Как сохранить данные при перевороте?
   - [Q11a](#q11a) В чем отличие между configchanges и savedinstancestate?
   - [Q12a](#q12a) Как при пересоздании активити сохранить некоторый объект (кроме onSaveInstanceState)?
   - [Q13a](#q13a) Как получить результат от другой Activity?
   - [Q14a](#q14a) Какие методы вызываются при переходе между активити?
   - [Q15a](#q15a) Когда `onDestroy()` вызывается без `onPause()` и `onStop()`?
   - [Q16a](#q16a) Почему `setContentView()` располагают в `onCreate()`?
   - [Q17a](#q17a) Как очистить бэкстек при создании активити?
   - [Q18a](#q18a) Разница между `FLAG_ACTIVITY_CLEAR_TASK` и `FLAG_ACTIVITY_CLEAR_TOP`?
   - [Q19a](#q19a) Launch modes
   - [Q20a](#q20a) Когда Activity удаляется из памяти?
   - [Q21a](#q21a) Чем отличается ActivityContext от ApplicationContext?
 
     ## Services
   - [Q22a](#q22a) Что такое Service ?
   - [Q23a](#q23a) Какие вы знаете виды сервисов?
   - [Q24a](#q24a) Жизненный цикл Service?
   - [Q25a](#q25a) Назовите отличие IntentService от Service?
   - [Q26a](#q26a) Зачем в Service нужен метод onBind()?
   - [Q27a](#q27a) Как остановить Service?
   - [Q28a](#q28a) Перезапуск сервиса

     ## Broadcasts
   - [Q29a](#q29a) Что такое BroadcastsReceiver?
   - [Q30a](#q30a) Можно ли отправить свое Broadcasts сообщение?
   - [Q31a](#q31a) Какие виды BroadcastsReceiver вы знаете?

     ## Content provider
   - [Q32a](#q32a) Зачем нужен Content Provider?

     ## Resources
   - [Q33a](#q33a) Для чего нужны resources?
   - [Q34a](#q34a) Как ресурсы хранятся приложение?
   - [Q35a](#q35a) Зачем такое разделение сделано на группы, если можно использовать один ресурс?
     Дополнительный вопрос
   - Как обратиться к ресурсу?

     ## ViewGroup
   - [Q36a](#q36a) Что такое `View`?
   - [Q37a](#q37a) На каком потоке стартует View
   - [Q38a](#q38a) Что такое `ViewGroup`?
   - [Q39a](#q39a) Виды разметки в Android?

     ## Custom Views
   - [Q40a](#q40a) Когда может понадобиться реализация собственного View?
   - [Q41a](#q41a) Какие способы создания Custom View вы знаете? 
   - [Q42a](#q42a) Иерархия View в Android
   - [Q43a](#q43a) Жизненный цикл View
   - [Q44a](#q44a) Конструкторы View
   - [Q45a](#q45a) Методы View
   - [Q46a](#q46a) Метод onLayout()
   - [Q47a](#q47a) Обновление `View`
   - [Q48a](#q48a) Атрибуты для Custom View
 
     ## Библиотеки загрузки приложений
  
   - [Q49a](#q49a) Coil
   - [Q50a](#q50a) Glide
   - [Q51a](#q51a) Picasso
   
   - [Fresco](#fresco)

    ## Дополнительные вопросы
   - Что такое Intent?
   - Что такое Bundle?
   - Какие способы регистрации BroadcastReceiver вы знаете? Чем они отличаются?
   - Как обратиться к ресурсу?
  
  

  
# Android<img src="https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExbnluOG4xdGlpeWxwYnFhM3Bjc2Z3dzN5eDhhaThza2N0Ym9wOGUxOCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/zECASgodRMZ5QAbRao/giphy.gif" width="30px">

### Q1a
### Какие проблемы может решить многопоточность?
-одновременное выполнение нескольких действий.

-ускорение вычислений.

-разгрузка пользовательского интерфейса (Android).

[Содержание](#содержание)

### Q2a
### Какой из этих компонентов не обязательно регистрировать в файле AndroidManifest и почему?
Один из компонентов Android-системы, который не обязательно регистрировать в AndroidManifest, это Content Providers. Content Providers предоставляют унифицированный интерфейс для доступа к данным, и могут использоваться другими приложениями для получения и обмена информацией. Однако, если не требуется внешний доступ к данным, Content Providers необязательно регистрировать в AndroidManifest.

[Содержание](#содержание)

### Q3a
### Расскажите про AndroidManifest и для чего он нужен?
Это Xml инструкция которая выполняется до запуска приложения и описывает его основную инфрмацию для системы. Каждое приложение имеет свой файл `AndroidManifest.xml` который находится в папке проекта manifest. В нем определяется название приложения, api андроида необходимое для работы приложения, методанные о версии, иконке, теме и т.д. Перечисляются общедоступные библиотеки которые связаны с приложением, например Google карты. Объявляются основные компоненты приложения. Например в элементе application мы можем объявлять `MainActivity` которая будет точкой доступа в приложении и откроется при его запуске, для этого необходимо указать в 

```xml
<activity android:name=".presentation.MainActivity">
  <intent-filter>
    <action android:name="android.intent.action.MAIN" />
    <category android:name="android.intent.category.LAUNCHER" />
  </intent-filter>
</activity>
```
В манифесте можно указать разрешения, которые должны запросить другие приложения для взаимодействия с нашим приложением. И список permission которые будут запрошены у системы для функционирования приложения, например доступ к интернету, камере, локации, контактам и т.д.

[Содержание](#содержание)

### Q4a
### Что происходит между тем как ты нажал на иконку приложения и его запуском?

Когда пользователь кликает на иконку приложения, лаунчер вызывает `startActivity()`, в который передается интент с main активити этого приложения. Вызов `startActivity()` делегируется в `ActivityManagerService` через `Binder IPC`. После этого `ActivityManagerService`: 
+ Получает информацию об активити методом `PackageManager.resolveIntent()`. 
+ Сохраняет информацию об активити в интент, чтобы не выполнять резолюшн в будущем. 
+ Проверяет, имеет ли приложение-лаунчер достаточно прав, чтобы стартовать активити. 
+ Проверяет, существует ли `ProcessRecord` для процесса приложения, которое нужно запустить.

[Содержание](#содержание)

# Android Components<img src="https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExbnluOG4xdGlpeWxwYnFhM3Bjc2Z3dzN5eDhhaThza2N0Ym9wOGUxOCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/zECASgodRMZ5QAbRao/giphy.gif" width="30px">

## ⭐Activity

### Q5a
### Что такое Activity?
Это компонент приложения, который представляет собой экран, с которым пользователи могут взаимодействовать для выполнения каких-либо действий, например набрать номер телефона, сделать фото, отправить письмо или просмотреть карту. Каждой `Activity` присваивается окно для прорисовки соответствующего пользовательского интерфейса.

[Содержание](#содержание)

### Q6a
### Как стартует первая Activity?
 Все начинается с лаунчера. Лаунчер — первое приложение, которое запускается системой. Он отличается от обычного приложения тремя вещами:

1️⃣ Главной `Activity` лаунчера устанавливается категория `HOME`, благодаря чему система будет вызывать эту `Activity` при нажатии на кнопку Home.

```xml
<category android:name="android.intent.category.HOME" />
```


2️⃣ Всем `Activity` лаунчера нужно выставить флаг `excludeFromRecents`, чтобы они не мелькали в `recents`.
```xml
<activity
   android:name=".MainActivity"
   android:excludeFromRecents="true"
```

3️⃣ `Activity` лаунчера пользователь будет видеть чаще всего.
Основная задача лаунчера — вывести красивый список других приложений. 

[Содержание](#содержание)

### Q7a
### Как можно переключаться между Activity?
#### Первый способ с помощью `Intent`-ов.

Intent
-определяет действие, которое необходимо выполнить, и может содержать URI с данными, над которыми необходимо совершить действие. Запускает 3 из 4 компонентов (Activity, Service, BroadcastReceiver). Для BroadcastReceiver просто содержит информацию о рассылке.
Для запуска нового экрана необходимо создать экземпляр класса Intent и указать в первом параметре текущий класс, а во втором - класс для перехода, у нас это AboutActivity. После этого вызывается метод startActivity(), который и запускает новый экран.</p>

```java
button.setOnClickListener {
    val intent = Intent(this@MainActivity, AboutActivity::class.java)
    startActivity(intent)
}
```
[Содержание](#содержание)

### Q8a
### Второй способ с помощью `putExtra()`.

Иногда требуется не только вызвать новый экран, но и передать в него данные.В этом случае нужно задействовать специальную область `extraData`, который имеется у класса `Intent`. 

Область `extraData` - это список пар ключ/значение, который передаётся вместе с intent-ом. В качестве ключей используются 
String, а для значений можно использовать любые примитивные типы данных, массивы примитивов, объекты класса Bundle, объекты которые реализуют интерфейсы `Serializable` и `Parcelable`.

Для передачи данных в другую активность используется метод `putExtra()`

Принимающая активность должна вызвать какой-нибудь подходящий метод: `getIntExtra()`, `getStringExtra()` и т.д.:

[Содержание](#содержание)

### Q9a
### Опишите жизненный цикл Activity.
Жизненный цикл представляет собой последовательность методов, которые вызываются в определенной последовательности во время создания/уничтожения/приостановки `Activity`.

<h3 align="center"><strong>Activity Lifecycles</strong></h3>
<p align="center">
  <img src="https://www.sysbunny.com/blog/wp-content/uploads/2021/04/Android-Activity-Lifecycle-768x917.jpg" alt="Preview">
</p>

+ `onCreate()`
Необходимо обязательно реализовать, поскольку система вызывает его при создании `Activity`. Важно именно здесь вызвать метод `setContentView()` для определения пользовательского интерфейса. Вызывается первым, во время создания `Activity`. Вызывается один раз, после чего наше `Activity` переходит в состояние `Created`. В данном методе мы инициализируем интерфейс нашего `Activity`, а также выполняем некоторую базовую логику, которая необходима нам для корректной работы `Activity`, например, создаём список с какими-либо данными. Также, в качестве аргумента метода `onCreate()` нам передаётся объект `Bundle`, который содержит в себе информацию, которая была предварительно сохранена, во время пересоздания `Activity`.

+ `onStart()`
Переводит нашу Activity в состояние `Started`, после чего `Activity` становится видно для пользователя. Метод может использоваться для какой-либо логики, которая взаимодействует с `UI`.

+ `onResume()`
Наше `Activity` переходит на передний план приложения (foreground) изменяя своё состояние на Resumed. После вызова данного метода, пользователь может взаимодействовать с `Activity`. В данном состоянии `Activity` остается до тех пор, пока не потеряет фокус, это может произойти, например, при переходе на другую `Activity`, либо при входящем телефонном звонке.

+ ` onPause()`
Наше `Activity` теряет фокус, больше не видно для пользователя и выходит из состояния foreground. При этом `Activity` не уничтожается и продолжает существовать. В этом методе, например, мы можем приостановить логику связанную с GPS навигацией, чтобы минимизировать расход батареи.

+ `onStop()`
Состояние `Activity` изменяется на `Stopped`. Вызывается, когда `Activity` не видно пользователю, например, при переходе на другой экран или при сворачивании приложения, а также при подготовке к полному уничтожению нашей `Activity`. системой.

+ `onDestroy()`
Метод вызывается непосредственно перед уничтожением нашей `Activity`, например, после вызова метода `finish()`, или переходе на предыдущую `Activity`, путём нажатия кнопки “назад”.
Если активность завершается, `onDestroy()` – это последний метод жизненного цикла, который вызывает `Activity`. Если `onDestroy()` вызывается в результате изменения конфигурации, система немедленно создает новый экземпляр активности вызывает `onCreate()` в новом экземпляре и новой конфигурации.
Метод `onDestroy()` должен освобождать все ресурсы нашей `Activity`.


[Содержание](#содержание)

### Q10a
### Что происходит при перевороте экрана `Activity`? Какие методы вызываются? Как сохранить данные при перевороте?
  При повороте экрана происходит пересоздание экземпляра `Activity`. Это происходит потому, что при изменении ориентации экрана меняется конфигурация устройства, и система решает перезапустить `Activity` с учетом новой конфигурации. В результате может происходить потеря прогресса, так как данные, 
  которые не были сохранены или восстановлены, будут потеряны.
Одной из причин, по которой происходит потеря прогресса, является связанный с этим жизненный цикл `Activity`. Когда экран поворачивается, вызывается метод `onDestroy()` для старой активити, а затем создается новая `Activity` путем вызова метода onCreate(). Это означает, что все данные, которые не были сохранены, будут утеряны

Вызываются коллбэки:  
+ ` onPause()`, `onStop()`, `onSaveInstanceState()`, `onDestroy()`

+ `onCreate()`, `onStart()`, `onRestoreInstanceState()`,  `onResume()`.


Для того, что сохранить какие-либо пользовательские данные и затем восстановить их в нашей `Activity`, используются следующие методы:

+ `onSaveInstanceState()`
Данный метод вызывается перед тем, как `Activity` будет уничтожена. Параметром метода является Bundle, в который мы будем складывать необходимые для сохранения данные. Рекомендуется сохранять данным способом информацию, объём которой не превышает 1 мегабайт, в случае превышения лимита мы получим ошибку `TransactionTooLargeException`.
+ `onRestoreInstanceState()`
Вызывается после метода `onStart()`. В данный метод мы получим наш <b>Bundle</b>, в котором была сохранена информация.

Стоит заметить, что Bundle с сохранёнными данными мы также получаем в методе `onCreate()`, но данную ситуацию нужно отдельно обрабатывать, чтобы не получить `NullPointerException`.

[Содержание](#содержание)

### Q11a
### В чем отличие между configchanges и savedinstancestate? 
-`onSavedInstanceState()` автоматически вызывается, когда активити вот-вот будет уничтожена, поэтому вы можете сохранить любое состояние в бандле, которое имеет ваше представление. 
-`android:configChanges()` сообщает активити, какие изменения конфигурации ей необходимо обработать самостоятельно. Таким образом, в этом случае активити не будет уничтожена и воссоздана, что сохранит информацию о вашем состоянии. 


[Содержание](#содержание)

### Q12a
### Как при пересоздании активити сохранить некоторый объект (кроме onSaveInstanceState)?

  - Методы [onRetainCustomNonConfigurationInstance()](https://developer.android.com/reference/android/support/v4/app/FragmentActivity.html#onretaincustomnonconfigurationinstance) и 
[getLastCustomNonConfigurationInstance()](https://developer.android.com/reference/android/support/v4/app/FragmentActivity.html#getlastcustomnonconfigurationinstance) класса `FragmentActivity` (или `AppCompatActivity`)?
- Если активити — просто держатель для фрагментов, лучше в самих фрагментах делать `setRetainInstance(true)` 

[Содержание](#содержание)

### Q13a
### Как получить результат от другой Activity?
Нужно вызвать метод `startActivityForResult()`.

[Содержание](#содержание)

### Q14a
### Какие методы вызываются при переходе между активити?
<br>A: `onCreate()`, `onStart()`, `onResume`
<br>A: *(переход)* `onPause()`
<br>B: `onCreate()`, `onStart()`, `onResume`
<br>A: `onStop()`
<br>B: *(обратный переход)* `onPause()`
<br>A: `onRestart`, `onStart()`, `onResume`
<br>B: `onStop()`, `onDestroy()`

   ![иллюстрация процесса](https://lh5.googleusercontent.com/-MMX3o4pdsd0/ToybUtq-EFI/AAAAAAAAAbw/ri5MQ1Jg5sI/s800/20111005_L0024_L_TwoActSchema.jpg) 

[Содержание](#содержание)

### Q15a
### Когда `onDestroy()` вызывается без `onPause()` и `onStop()`?
  - Если активити закрывается через метод `finish()` до начала `onStart()` и `onResume`.

[Содержание](#содержание)

### Q16a  
### Почему `setContentView()` располагают в `onCreate()`?
  - Это тяжёлая операция, и выгоднее производить её только единожды, при создании активити.
 
[Содержание](#содержание)

### Q17a   
### Как очистить бэкстек при создании активити?
  - Использовать флаг `FLAG_ACTIVITY_CLEAR_TOP`. 
  - Использовать `FLAG_ACTIVITY_CLEAR_TASK` и `FLAG_ACTIVITY_NEW_TASK` вместе.
    
[Содержание](#содержание)

### Q18a
### Разница между `FLAG_ACTIVITY_CLEAR_TASK` и `FLAG_ACTIVITY_CLEAR_TOP`?
  - Первый очистит всё, что есть в таске, второй — только до той же активити, что и запускаемая.
  
[Содержание](#содержание)

### Q19a
### Launch modes
  - **SingleTop** Активити создаётся заново, только если она не вверху активити-стека. 
  - **SingleTask** Стек стирается до момента, пока эта активити не окажется наверху стека.
  - **SingleInstance** Похож на SingleTask, но при создании активити, она уйдёт в новый таск.
  
[Содержание](#содержание)

### Q20a
### Когда Activity удаляется из памяти?
  1. Использование метода finish(): этот метод завершает текущую Activity и освобождает память, занимаемую ею. При вызове метода finish() пользователь будет перенаправлен к предыдущей активности в стеке, и текущая Activity будет полностью удалена из памяти.
  2. Использование метода onBackPressed(): этот метод вызывается при нажатии пользователем кнопки «Back». По умолчанию этот метод закрывает текущую Activity и освобождает память, занимаемую ею.
  3. Использование флага Intent.FLAG_ACTIVITY_CLEAR_TOP: этот флаг используется при создании Intent, чтобы удалить все Activity, которые находятся выше в стеке запущенных активностей, и перейти к указанной Activity. Это полезно, когда мы хотим удалить все промежуточные Activity, чтобы вернуться к определенному экрану.
   
   Важно отметить, что Android система автоматически уничтожает Activity, которые не используются и занимают слишком много памяти. Однако в некоторых случаях может быть полезно явно удалить Activity из ОЗУ вручную с помощью вышеуказанных методов.

[Содержание](#содержание)

### Q21a   
### Чем отличается ActivityContext от ApplicationContext?

[Содержание](#содержание)

## ⭐Services

### Q22a
### Что такое Service ?
Service – это компонент приложения, который используется для выполнения долгих фоновых операций без взаимодействия с пользователем.

Любой компонент приложения может запустить сервис, который продолжит работу, даже если пользователь перейдет в другое приложение.

Примеры использования сервисов: проигрывание музыки, трекинг локации водителя в приложении такси, загрузка файла из сети.

Сервисы делятся на два вида по способу использования: Started и Bound, и на два вида по способу взаимодействия с пользователем: Background и Foreground.

[Содержание](#содержание)

### Q23a
### Какие вы знаете виды сервисов?
  + `Service` 
  + `Foreground` - Выполняется в основном потоке. Во время исполнения показывает уведомление. Пример — аудиоплеер.
  + `Background` - Выполняется в главном потоке. Начиная с API 26, приложения в фоне не могут создавать фоновые сервисы, решением в этом случае может быть `WorkManager`.
  + `IntentService` - Создаёт и работает в фоновом потоке, выполняет работу из метода `onHandleIntent()`, после чего останавливается. Операции в `onHandleIntent()` не могут быть прерваны, связь с основным потоком отсутствует. Он `Depricated`.
  + `Bound` Клиент-серверный подход: посылаем запросы, получаем результаты.
  + `JobService`
  + `JobIntentService`
  + `AlarmManager` 
  + `WorkManager` (Это не сервис, но под копотом искользует сервисы.Он используется для планирования и выполнения задачь в фоне.)
  
[Содержание](#содержание)

### Q24a
### Жизненный цикл Service?
   + `onCreate()` - создание Service.
 + `onStartCommand()` - Service выполняет работу
 + `onDestroy()` - Service уничтожается.

 Диаграмма ниже показывает жизненный цикл когда сервис создан с startService(), диаграмма справа показывает жизненный цикл когда сервис создан с bindService().
  
![иллюстрация](https://s1.o7planning.com/web-rs/web-image/ru/arf-1049789-en.webp)

[Содержание](#содержание)

### Q25a
### Назовите отличие IntentService от Service?
1.Работа в обычном сервисе по умолчанию выполняется на главном потоке, а работа в IntentService выполняется в фоновом потоке.

2.В обычном сервисе нужно переопределить метод onStartComand(), а в IntentService - onHandleIntent().

3.Если прилетит несколько задачь, то в обычном сервисе они все начнут выполняться сразу, в IntentService будет создаваться очередь. 

4.IntentService используется при выполнении одного задания, т.е. при завершении задания сервис самоуничтожается.

![иллюстрация](https://s1.o7planning.com/web-rs/web-image/ru/arf-1049801-en.webp)

[Содержание](#содержание)

### Q26a
### Зачем в Service нужен метод onBind()?
  Если на какой то сервис нужно подписаться и получать от него какие то данные на экране, то для этого можно вызвать метод bindService(). В этот момент будет вызван метод onBind() который должен вернуть реализацию интерфейса IBinder.

  - Метод `startService()`
  - `startService()` не размножает экземпляры сервиса, а только создает очередь из заданий для него. И если IntentService просто выполнит все задания последовательно, одно за другим, то благодаря классу Service у нас появляется возможность запустить все задачи одновременно в независимых потоках. Достаточно в методе onStartCommand создавать новые потоки для каждой задачи.

[Содержание](#содержание)

### Q27a
### Как остановить Service?
  - Сервис, создaнный с помощью одноименного класса, будет жить, пока его принудительно не остановят. Сделать это можно либо откуда-то снаружи методом `stopService()`, с указанием интента, которым он был запущен, либо внутри самого сервиса методом `stopSelf()`. 
  ### Как узнать, что сервис уже все сделал, особенно если мы поставили перед ним сразу несколько задач? 
  В этом нам поможет параметр startId у метода `onstartcommand()` — это порядковый номер каждого вызова сервиса, который увеличивается на единицу при каждом запуске. 

  - Создав новый поток, разумно завeршать его методом `stopSelf()`, указывая `startId` в качестве параметра. С таким параметром ОС не будет сразу завершать сервис, а сравнит переданный идентификатор с тем, который был выдан при последнем запуске `onStartCommand()`. Если они не равны, значит, в очередь была добавлена новая задача и сервис остановлен не будет.

[Содержание](#содержание)

### Q28a
### Перезапуск сервиса
  - Даже если ОС и внeштатно выгрузит сервис из памяти, есть возможность его запустить заново, кaк только появятся свободные ресурсы. 
  
  - Метод `onStartCommand()` возвращает переменную, указывaющую ОС, как следует поступить с сервисом, если он был принудительно остановлен. Существует три варианта того, как ОС может поступить с сервисом, если он был принудительно завершен:
    - `START_NOT_STICKY` — не будет перезапущен системой, и все останется так, как есть. Подходит для случая, когда он выпoлняет не самые важные задачи, и приложение может позже при необходимости самостоятельно его перезапустить. 
    - `START_STICKY` — будет запущен заново, но в Intent, который ОС создаст для его запуска, не будет никаких параметров. Такой вариант работает с аудиоплеерами — он должен быть активным в фоне, но не обязательно при этом автоматически начинать проигрывать песни. 
    - `START_REDELIVER_INTENT` — сервис будет запущен с теми же параметрами, которые были при его последнем старте. Это удобно, когда в фоне загружается большой файл и его загрузка была прервана. 

[Содержание](#содержание)

  ## ⭐Broadcasts

### Q29a
### Что такое BroadcastsReceiver?
  Это один из компонентов Android системы, который позволяет подписываться на различные сообщения, например поступил телефонный звонок, батарея разряжена и т.д.

[Содержание](#содержание)

### Q30a
### Можно ли отправить свое Broadcasts сообщение?
  Да, можно. Для этого нужно вызвать метод `sendBroadcast()`, который есть у context.

[Содержание](#содержание)

### Q31a
### Какие виды BroadcastsReceiver вы знаете?
#-[Содержание](#содержание)

## ⭐Content provider

### Q32a  
### Зачем нужен Content Provider
  Он нужен для организации доступа к данным из других приложений. В качестве примера приложение Контакты, куда занесены все данные, номера телефонов, имена и т.д., а другие приложения могут этим пользоваться. Например в банковском приложении мы можем выбрать контакт которому хотим перевести деньги. 
  - Используется в связке с `ContentResolver`.


#-[Содержание](#содержание)

## ⭐Resources

### Q33a
### Для чего нужны resources?
Приложение android состоит не только из кода, но ему также требуется изображения, файлы, аудио, нужно определять цвета макет интерфейса, анимации и все это помещается в xml файлах. Это так называемый статический контент. Ресурсы всегда содержатся отдельно их можно изменять и поддерживать независимо от остального приложения. Также можно предоставлять альтернативные ресурсы для разных конфигурации устройства. Ресурсы хранятся в папках. 

После того как вы создали или загрузили свой ресурс, на него можно сослаться с помощью его `id`. Они определены в `R`(глобальный идентификатор ресурсов) классе нашего приложения, а R-class он создается автоматически с помощью инструмента `android asset packaging tool` этот инструмент встроен в android studio. Он индексирует наши ресурсы, компилирует их в двоичном формате. Мы можете сослаться после этого на этот R-class, на подгруппу ресурсов. Это может быть color, string и вызвать наш ресурс по `id`. Сослаться на ресурс можно через символ `@`.

[Содержание](#содержание)

### Q34a
### Как ресурсы хранятся в приложении?

Каждый android проект имеет android ресурс директорию под названием `res`, она хранится в папочке `main` нашего проекта. Здесь собраны все ресурсы, сгруппированы по папкам и папки имеет строгие названия. Есть специальное соглашение о том, где и какие ресурсы должны храниться. В папке anim и animator хранятся разные типы анимации android, они заданы в xml файле. 

В папочке `color` хранится так называемый лист состоянии цветов, он описывает то, как ведет и как меняется цвет в определенном состоянии элемента. Мы можем присваивать данный xml файл на кнопку, а кнопка у нас имеет разные состояния. Она может быть нажата, она может быть выбрана если используется мышка, может быть события наведения на этот элементы, для всех этих состояний цвет должен меняться как раз он описывается в таких стейт листах. 
+ `drawable` - папка предназначена для хранения графических файлов, либо xml файлов, с помощью которых можно изменять графическое состояние объектов, либо тоже создавать объекты через определён API. 

+ Типы файлов: gif, png, jpg , можно также хранить векторную графику, можно хранить файлы которые влияют на отрисовку растровой графики в различных состояниях(например как color при нажатии, при наведении) также есть различные animations, которые описывают анимации для графических объектов. Scale drawable которыe управляют изменением размера drawable. 

+ `Clip drawable` с помощью которого можно описывать обрезку вашего графического изображения. 

-Drawables (Bitmap Images, Layer List, State List, Shape, Vector images)-папка предназначена для хранения графических файлов, либо xml файлов, с помощью которых можно изменять графическое состояние объектов, либо тоже создавать объекты через определённый API. Имеется несколько папок с подобным названием под конкретный размер экрана.

-Assets-служит для хранения файлов в оригинальном виде, но ее отличие еще в том что файлы в ней не доступны через R-class, они доступны только через обращение через AssetManager.
-Layouts-макеты дизайна для activity, для фрагментов, для view holders, для различных виджетов, которые мы создаём. Имеется несколько папок с подобным названием 
для горизонтальной ориентации (layout-land), под конкретный размер экрана (layout-sw320dp) и т.д.
-Animation (Animator, PropertyAnimations)-анимации для различных view.
-Fonts-шрифты.

[Содержание](#содержание)

### Q35a
### Зачем такое разделение сделано на группы, если можно использовать один ресурс? 
Нужно это для оптимизации выделяемой памяти и процессорного времени для отрисовки изображения. Если мы будем использовать изображение высокого разрешения и отображать его на маленьком телефоне, с маленьким экраном относительно ничего плохого не случится, но из за того что это изображение сжимается тратит больше процессорных ресурсов и у нас таким образом замедляется отрисовка! Вот так же наоборот если мы будем использовать файл недостаточного разрешения и положим его папочка mdpi и отобразим его на телефоне с большим экраном и но у нас может быть размытым и некачественным. Лучший вариант это нарезать растровую графику для различных разрешений,но тут стоит понять одну простую вещь, количество пикселей оно отличается на разных плотностях экрана, поэтому в андроиде чаще всего используется размер в density independent pixel, это пиксели который не зависит от плотности.

+ `layout` и `layout-land` представленные макеты дизайна для activity, для фрагментов, для view holders, для различных виджетов, которые мы создаём.
  
+ `layout` хранятся ресурсы по умолчанию.
  
+ `layout-land` для горизонтальной ориентации. 
  
+ `menu` в android приложение это могут быть выпадающее меню, либо меню для нижней навигации.
  
+ `raw` в ней ресурсы хранятся в оригенальном виде, и к ним можно достучаться с помощью обращений через R-class. Например можно хранить мелодии в формате mp4.  
+ папка `asats` она находится не в ресурсах, а отдельно в папке main. она тоже служит для хранения файлов в оригинальном виде, но ее отличие еще в том что файлы в ней не доступны через R-class, они доступны только через обращение через AssetManager.

[Содержание](#содержание)

## Дополнительный вопрос
### Как обратиться к ресурсу?
-когда приложение скомплировано, aapt генерирует класс R, который содержит идентификаторы для всех ресурсов в папке res. Для каждого типа ресурса существует подкласс R (R.drawable) и для каждого ресурса этого типа существует статическое целое число (R.drawable.mydrawable). Это число и является идентификатором с помощью которого можно получить ресурс.

## ⭐ViewGroup

### Q36a
#### Что такое `View`?
View это базовый класс для создания элементов пользовательского интерфейса в Android приложении. Это контейнер который содержит в себе другие View. Представляет из себя прямоугольную область и отвечает за обработку событий (например клика по экрану) и их отображение. `UI` элементы являются наследниками класса `View`, например `Button`, `TextView` и т.д. Обязательными параметрами у элементов являются ширина `android:layout_width` и высота `android:layout_height`.

[Содержание](#содержание)

### Q37a
#### На каком потоке стартует View?
Вся работа View выполняется в Главном потоке.

[Содержание](#содержание)

### Q38a
### Что такое `ViewGroup`?
`ViewGroup` это класс, который наследуется от `View`. Предназначенный для хранения в себе других элементов `View`, например несколько `Button` и `ImageView`. Является базовым классом для контейнеров `UI` элементов, таких как `LinearLayout`, `ConstraintLayout`, `RecyclerView` и т.д.

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
   android:layout_width="fill_parent" 
   android:layout_height="fill_parent"
   android:orientation="vertical" >
   
   <TextView 
      android:id="@+id/text_id"
      android:layout_width="wrap_content"
      android:layout_height="wrap_content"
      android:text="I am a TextView" />

   <Button 
      android:id="@+id/button_id"
      android:layout_width="wrap_content"
      android:layout_height="wrap_content"
      android:text="I am a Button" />

</LinearLayout>
```

В примере выше подкласс `ViewGroup` –  контейнер `LinearLayout`, который содержит в себе несколько наследников класса `View` – `TextView` и `Button`.

У любого объекта может быть связанный с ним целочисленный идентификатор, который служит для обозначения уникальности объекта `View` в иерархии.

[Содержание](#содержание)

### Q39a
### Виды разметки в Android?

Основные виды разметки:
+ `LinearLayout`
Разметка, в которой элементы располагаются цепочкой поочередно. При указании параметра `android:orientation=”vertical”` View элементы располагаются друг под другом вертикально. При указании параметра `android:orientation=”horizontal”` View элементы располагаются друг за другом горизонтально.

+ `FrameLayout`
Разметка, в которой элементы прикрепляются к верхнему левому углу экрана и их местоположение нельзя изменить. При добавлении нескольких элементов в `FrameLayout` они будут рисоваться поверх предыдущих, если их размеры совпадают, либо частично перекрывать друг друга.

+ `RelativeLayout`
Разметка, в которой элементы располагаются относительно родительского компонента или относительно соседних `View` элементов (по идентификатору элемента).

+ `ConstraintLayout`
Разметка, схожая по принципу с `RelativeLayout`. У каждого `View` элемента есть линии, на основании которых `View` располагается внутри `ConstraintLayout`. Эти линии (constraints) могут быть привязаны к сторонам самого `ConstraintLayout` или к сторонам других `View` внутри `ConstraintLayout`

+ `TableLayout`
Разметка, в которой элементы располагаются в табличной форме со строками и столбцами. Внутри `TableLayout` необходимо создавать элементы `TableRow`, которые будут являться строками и выстраиваться вертикально. Внутри `TableRow` можно размещать другие элементы, которые будут выстраиваться горизонтально. `TableLayout` не отображает разделительных линий для их строк, столбцов и ячеек, их необходимо реализовывать самостоятельно. Может иметь строки с разным количеством ячеек.

[Содержание](#содержание)

## ⭐Custom Views
Обычно термин Custom View обозначает View, которого нет в sdk Android. Другими словами — это пользовательская реализация View, которая может содержать собственную логику и визуальный интерфейс.

[Содержание](#содержание)

### Q40a
### Когда может понадобиться реализация собственного View?

— Специфичный дизайн или анимация
Если в стандартных View недостаточно функциональности, и нужно добавить новые возможности (график функции, сложная диаграмма).

— Специфичная обработка жестов
Свайп, тап, зум, поворот элемента по двойному касанию и другие комбинации жестов для взаимодействия с элементами интерфейса.

— Улучшение производительности
Например, для оптимизации отображения большого количества графических объектов (карта с большим количеством маркеров).

[Содержание](#содержание)

### Q41a
### Какие способы создания Custom View вы знаете? 
— Расширение функциональности стандартного View или ViewGroup
Допустим, что нам не хватает стандартных возможностей Button. Мы создаём свой класс и наследуемся от класса android.widget.Button. Затем переопределяем методы для отображения и обработки событий. Этот подход используется для дополнения функциональности существующих элементов View или изменения их внешнего вида.

— Создание кастомного класса View с нуля
Этот способ подходит, если мы хотим создать свой собственный элемент View. Создаем класс, который наследуется от класса View, а затем переопределяем методы для отображения и обработки событий. Этот метод пригодится для создания сложных и уникальных пользовательских интерфейсов (кастомный прогресс-бар, графики или диаграммы).

— Использовать существующие библиотеки
Можно использовать существующие библиотеки, которые предоставляют набор готовых компонентов и методов для построения UI и могут быть настроены под ваш проект. Такой подход позволяет сэкономить время на разработку, но ограничивает вас возможностями библиотеки. Пример: MPAndroidChart для создания различных графиков и диаграмм.

[Содержание](#содержание)

### Q42a
### Иерархия View в Android
![иллюстрация процесса](https://habrastorage.org/r/w1560/getpro/habr/upload_files/30f/d32/d07/30fd32d07bb0a5eeaa1a440ec2f833b8.png) 

[Содержание](#содержание)

### Q43a
### Жизненный цикл View
Полная версия жизненного цикла View:
![иллюстрация процесса](https://habrastorage.org/r/w1560/getpro/habr/upload_files/938/dd5/157/938dd5157bc6242a7a1d2367cfe28e6d.png) 

При создании Custom View мы используем лишь методы с приставкой On, поэтому схему можно упростить:
![иллюстрация процесса](https://habrastorage.org/getpro/habr/upload_files/ec3/496/516/ec34965166cad6fa0392b422391c6480.png) 

[Содержание](#содержание)

### Q44a
### Конструкторы View
Создание View начинается с конструктора с различными параметрами: `Context`, `AttributeSet`, `defStyleAttr` и `defStyleRes`. View имеет четыре конструктора, и вам нужно будет переопределить хотя бы один из них:

```kotlin
class TestView : View {
    constructor(context: Context?) : super(context)
    constructor(context: Context?, attrs: AttributeSet?) : super(context, attrs)
    constructor(context: Context?, attrs: AttributeSet?, defStyleAttr: Int) : super(
        context,
        attrs,
        defStyleAttr
    )

    constructor(
        context: Context?,
        attrs: AttributeSet?,
        defStyleAttr: Int,
        defStyleRes: Int
    ) : super(context, attrs, defStyleAttr, defStyleRes)
} 
```
В Kotlin можно использовать @JvmOverloads. Эта аннотация генерирует все возможные комбинации параметров конструктора, которые могут быть использованы при вызове из Java.

```kotlin
class TestView @JvmOverloads constructor(
    context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0, defStyleRes: Int = 0
) : View(context, attrs, defStyleAttr) {
    // Your code here
}
```

1.Конструктор с одним параметром — Context

Используется только в том случае, если View мы хотим создавать из кода, а не из XML.

2.Конструктор с двумя параметрами — Context и AttributeSet

Используется для создания View с использованием XML-макета. В этом конструкторе можно получить значения атрибутов View, указанных в XML-разметке, и использовать их для настройки свойств вашего Custom View.

3.Конструктор с тремя параметрами — Context, AttributeSet и defStyleAttr

Вызывается при создании View с помощью XML-разметки и задании значения стиля (defStyleAttr) из темы.

4.Конструктор с четырьмя параметрами — Context, AttributeSet, defStyleAttr и defStyleRes

Также используется для создания View с использованием XML-макета, со стилем из темы и/или с ресурсом стиля.

### Q45a
### Методы View
#### 1.Метод onAttachToWindow()

После вызова данного метода, наша View прикрепляется к нашему Activity и знает о других элементах, которые также находятся на этом экране.

#### 2.Метод onMeasure()

Конечная цель метода onMeasure() — определить размер и расположение вашего View на экране. В качестве параметров он принимает две переменные widthMeasureSpec и heightMeasureSpec, которые в свою очередь представляют собой требования измерения ширины и высоты вашего View. При переопределении данного метода, необходимо указать ширину и высоту вашего View самостоятельно, используя метод setMeasuredDimension().
```kotlin
class CustomView(context: Context, attrs: AttributeSet) : View(context, attrs) {

    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec)
        val width = MeasureSpec.getSize(widthMeasureSpec)
        val height = MeasureSpec.getSize(heightMeasureSpec)
        setMeasuredDimension(width, height)
    }
}
```

`MeasureSpec` — это класс, используемый для определения размеров View в Android. Когда View помещается на экран, ей нужно знать, какое место ей предоставлено, чтобы правильно расположиться и отобразиться. `MeasureSpec` состоит из двух основных компонентов: размера и режима измерения.

Режим измерения может быть одним из трех типов:

`EXACTLY` (точно) — размер View должен быть задан точно (например, в dp или px). Это может быть указано в макете View с атрибутом android:layout_width или android:layout_height со значением фиксированной ширины или высоты.

`AT_MOST` (не больше) — View может быть любого размера, который не превышает указанный максимальный размер, например, layout_width="wrap_content". Это означает, что View может иметь любой размер, пока он не превышает размер родительского контейнера.

`UNSPECIFIED` (неопределенный) — размер View может быть любым, не ограниченным размером родителя.

Для каждого измерения View, то есть для ширины и высоты, используется отдельный MeasureSpec. Он передается в метод onMeasure() в качестве аргумента. Для того, чтобы получить размеры View на основе MeasureSpec, можно использовать методы MeasureSpec.getSize() и MeasureSpec.getMode():

`getSize(measureSpec: Int)` — извлекает размер из заданного объекта MeasureSpec.

`getMode(measureSpec: Int)` — извлекает режим из заданного объекта MeasureSpec.

Пример использования MeasureSpec в методе onMeasure():

```kotlin
override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {
    val desiredWidth = 100 // Предполагаемая ширина View
    val desiredHeight = 100 // Предполагаемая высота View

    val widthMode = MeasureSpec.getMode(widthMeasureSpec)
    val widthSize = MeasureSpec.getSize(widthMeasureSpec)
    val heightMode = MeasureSpec.getMode(heightMeasureSpec)
    val heightSize = MeasureSpec.getSize(heightMeasureSpec)

    val width = when (widthMode) {
        MeasureSpec.EXACTLY -> widthSize // Задан конкретный размер для ширины
        MeasureSpec.AT_MOST -> min(desiredWidth, widthSize) // Размер не должен превышать заданный размер
        else -> desiredWidth // Задать предпочтительный размер, если точного или максимального размера не задано
    }

    val height = when (heightMode) {
        MeasureSpec.EXACTLY -> heightSize // Задан конкретный размер для высоты
        MeasureSpec.AT_MOST -> min(desiredHeight, heightSize) // Размер не должен превышать заданный размер
        else -> desiredHeight // Задать предпочтительный размер, если точного или максимального размера не задано
    }

    setMeasuredDimension(width, height) // Устанавливаем фактический размер View
}
```

### Q46a
#### Метод onLayout()

Метод onLayout() вызывается при каждом изменении размера и позиции View, в том числе при его создании и перерисовке. Обычно этот метод переопределяется в Custom View только в том случае, когда в нем есть дочерние View, которые нужно разместить в определенном порядке.
#### 4.Метод onDraw()

Основной метод при разработке собственной View. При переопределении метода onDraw() используется объект Canvas (2D-холст), на котором можно рисовать графические элементы. Также в этом методе можно использовать объекты Paint и Path, которые определяют стиль и форму рисуемых элементов.

#### a.Canvas

Canvas предоставляет нам методы для рисования фигур, линий, текста и других элементов на экране, например:

+ `drawColor(color: Int)` — заливает всю область цветом, указанным в аргументе.

+ `drawLine(startX: Float, startY: Float, stopX: Float, stopY: Float, paint: Paint)` — рисует линию, заданную двумя точками.

+ `drawRect(left: Float, top: Float, right: Float, bottom: Float, paint: Paint)` — рисует прямоугольник, заданный координатами левого верхнего и правого нижнего углов.

+ `drawCircle(cx: Float, cy: Float, radius: Float, paint: Paint)` — рисует круг, заданный координатами центра и радиусом.

+ `drawText(text: String, x: Float, y: Float, paint: Paint)` — рисует текст, заданный строкой и координатами базовой точки.

#### b.Paint

Объект Paint представляет собой кисть, с помощью которой мы рисуем на Canvas.
Примеры методов для `val paint = Paint()`:

`color` (цвет рисования) — `paint.color = Color.RED`

`strokeWidth` (ширина линии рисования) — paint.strokeWidth = 10f`

`style` (стиль рисования) — `paint.style = Paint.Style.FILL`. Принимает в качестве параметра одно из значений класса Paint.Style: FILL, STROKE или FILL_AND_STROKE.

`textSize` (размер шрифта текста) — `paint.textSize = 30f`

Пример использования Paint и Canvas:

```kotlin
class MyCustomView(context: Context, attrs: AttributeSet?) : View(context, attrs) {

    private val paint = Paint()

    override fun onDraw(canvas: Canvas) {
        super.onDraw(canvas)

        // Устанавливаем цвет и стиль для Paint
        paint.color = Color.RED
        paint.style = Paint.Style.FILL

        // Рисуем круг на Canvas
        canvas.drawCircle(width / 2f, height / 2f, 100f, paint)

        // Устанавливаем цвет и стиль для Paint
        paint.color = Color.BLUE
        paint.style = Paint.Style.STROKE
        paint.strokeWidth = 10f

        // Рисуем прямоугольник на Canvas
        canvas.drawRect(50f, 50f, 200f, 200f, paint)
    }
}
```
Создание объектов в `onDraw()` может привести к лишним затратам памяти и ухудшению производительности приложения. Метод `onDraw()` вызывается при каждой перерисовке `View`, поэтому слишком частое создание новых объектов `Paint` может вызвать нагрузку на сборщик мусора. Вместо этого рекомендуется создать объект `Paint` в конструкторе класса или в другом подходящем методе и переиспользовать его в методе `onDraw()`.

Таким образом, вместо создания новых объектов `Paint` в методе `onDraw()`, лучше создать их в конструкторе класса, например:

```kotlin
class MyCustomView(context: Context, attrs: AttributeSet?) : View(context, attrs) {
    private val fillPaint = Paint().apply {
        color = Color.RED
        style = Paint.Style.FILL
    }
    
    private val strokePaint = Paint().apply {
        color = Color.BLUE
        style = Paint.Style.STROKE
        strokeWidth = 10f
    }

    override fun onDraw(canvas: Canvas) {
        super.onDraw(canvas)

        // Рисуем круг на Canvas
        canvas.drawCircle(width / 2f, height / 2f, 100f, fillPaint)

        // Рисуем прямоугольник на Canvas
        canvas.drawRect(50f, 50f, 200f, 200f, strokePaint)
    }
}
```

В этом примере мы создаем два объекта `Paint` в конструкторе класса и настраиваем их свойства один раз. Затем мы используем эти объекты `Paint` в методе `onDraw()` для рисования круга и прямоугольника на `Canvas`. Таким образом, мы избегаем создания новых объектов `Paint` при каждой перерисовке `View` и уменьшаем нагрузку на сборщик мусора.

Далее еще несколько полезных методов, которые вы будете применять при разработке собственного `View`.

#### c.Метод `onSizeChanged()`

Метод `onSizeChanged()` вызывается при изменении размеров `View` (смена ориентация устройства, изменение размера родительского контейнера) и может быть переопределен в кастомном `View` для реакции на эти изменения. Метод имеет следующую сигнатуру:
```kotlin
override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) {
    super.onSizeChanged(w, h, oldw, oldh)
    // Your code here
}
```

`w` — новая ширина View

`h` — новая высота View

`oldw` — старая ширина View

`oldh` — старая высота View

В `onSizeChanged()` мы как раз выполняем нужные расчеты, подготавливаем данные для дальнейшей отрисовки в методе `onDraw()`. В идеале, мы не ведем никакие расчеты в `onDraw()`, а берем конкретные подготовленные цифры и просто рисуем.

Пример использования:

```kotlin
class TestView @JvmOverloads constructor(
    context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0
) : View(context, attrs, defStyleAttr) {

    private val circlePaint = Paint().apply {
        color = Color.RED
        style = Paint.Style.FILL
    }
    private val rectPaint = Paint().apply { color = Color.BLUE }
    private val arcPaint = Paint().apply { color = Color.GREEN }
    private val rectF = RectF()
    private val arcRectF = RectF()

    private var centerX = 0f
    private var centerY = 0f

    override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) {
        super.onSizeChanged(w, h, oldw, oldh)
        rectF.left = 20f
        rectF.top = 40f
        rectF.right = w - 20f
        rectF.bottom = h - 40f

        arcRectF.left = 20f
        arcRectF.top = 40f
        arcRectF.right = w - 20f
        arcRectF.bottom = h - 40f

        centerX = w / 2f
        centerY = h / 2f
    }

    override fun onDraw(canvas: Canvas) {
        super.onDraw(canvas)
        canvas.drawRect(rectF, rectPaint)
        canvas.drawCircle(centerX, centerY, 100f, circlePaint)
        canvas.drawArc(arcRectF, 180f, 90f, true, arcPaint)
    }
}
```

#### d.Методы `onSaveInstanceState()` и `onRestoreInstanceState()`

Методы `onSaveInstanceState()` и `onRestoreInstanceState()` позволяют сохранять и восстанавливать состояние `View` в случае, когда система уничтожает и пересоздает `View`, например, при повороте экрана или при нехватке памяти.

Метод `onSaveInstanceState()` вызывается перед уничтожением View, и в нем необходимо сохранить состояние. В этом методе можно поместить все нужные нам данные в Bundle с помощью метода `put...()`, например:

```kotlin
override fun onSaveInstanceState(): Parcelable {
    val bundle = Bundle()
    bundle.putString("text", textView.text.toString())
    bundle.putParcelable("instanceState", super.onSaveInstanceState())
    return bundle
}
```

Здесь мы сохраняем текст, отображаемый в `textView` в Bundle, который затем возвращается в качестве результата. Также мы вызываем `super.onSaveInstanceState()` и передаем его результат в Bundle с помощью метода `putParcelable()`, чтобы сохранить состояние базового класса.

Метод `onRestoreInstanceState()` вызывается после того, как `View`была пересоздана, чтобы восстановить ее состояние из `Bundle`. В этом методе можно извлечь необходимые данные из `Bundle` с помощью метода `get...()`, например:

```kotlin
override fun onRestoreInstanceState(state: Parcelable?) {
    val bundle = state as Bundle
    textView.text = bundle.getString("text")
    super.onRestoreInstanceState(bundle.getParcelable("instanceState"))
}
```

Здесь мы восстанавливаем текст в `textView` из `Bundle`, который был передан в качестве параметра. Также мы вызываем метод super.`onRestoreInstanceState()` и передаем ему сохраненное состояние базового класса с помощью метода `getParcelable()`.

Метод `onRestoreInstanceState()` может вызываться после метода `onFinishInflate()`, поэтому необходимо учитывать это при восстановлении состояния `View`.

Также стоит отметить, что эти методы могут работать только с `Serializable` или `Parcelable` типами данных. Если вам нужно сохранить другой тип данных, например, объект вашего собственного класса, то вам необходимо реализовать его сериализацию и десериализацию в методах `onSaveInstanceState()` и `onRestoreInstanceState()` соответственно.

#### e.Метод onTouchEvent()

Метод `onTouchEvent()` — это один из методов обработки событий пользовательского ввода в `View`. Вызывается при каждом событии касания на `View`, например при нажатии, перемещении или отпускании пальца.

Метод возвращает значение типа `Boolean`, которое указывает, было ли событие обработано этим методом. Если метод возвращает `true`, это означает, что событие было обработано и больше никаких действий не требуется, если он возвращает `false`, событие продолжит свой путь по иерархии `View` и будет обработано другими методами.

Пример использования `onTouchEvent()` в кастомной `View`:
```kotlin
class MyCustomView(context: Context, attrs: AttributeSet) : View(context, attrs) {

    override fun onTouchEvent(event: MotionEvent): Boolean {
        when (event.action) {
            MotionEvent.ACTION_DOWN -> {
                // обработка нажатия пальца на экран
                return true
            }
            MotionEvent.ACTION_MOVE -> {
                // обработка перемещения пальца по экрану
                return true
            }
            MotionEvent.ACTION_UP -> {
                // обработка отпускания пальца от экрана
                return true
            }
        }
        return super.onTouchEvent(event)
    }
}
```
В этом примере мы переопределяем метод `onTouchEvent()` и используем его для обработки трех основных событий касания на экране:

`ACTION_DOWN` — когда палец нажимается на экран
`ACTION_MOVE` — когда палец перемещается по экрану
`ACTION_UP` — когда палец отпускается от экрана.

Внутри каждого из этих блоков мы можем написать нужный нам код для обработки события, например, изменения цвета или размера `View`, а также возвращаем `true`, чтобы указать, что событие было обработано и больше никаких действий не требуется. Если событие не было обработано внутри блоков when, мы вызываем метод `super.onTouchEvent(event)`, чтобы передать событие на обработку другим методам в иерархии `View`.

### Q47a
### Обновление `View`

Когда данные, используемые внутри `View`, изменяются, требуется обновить `View`, чтобы отобразить новые значения. Из диаграммы жизненного цикла видно, что существуют два метода, которые заставляют `View` перерисовываться:

`invalidate()` — используется, когда нужно только перерисовать ваш элемент.

`requestLayout()` — используется, когда нужно изменить размеры вашего View.

#### a.Метод `invalidate()`

Для обновления визуальной части нашего `View`, используется метод `invalidate()`. Например, когда ваш `View`-компонент обновляет свой текст, цвет или обрабатывает прикосновение. Это значит, что `View`-компонент будет вызывать только метод `onDraw()`, чтобы обновить своё состояние.

Пример использования:
```kotlin
class CustomView(context: Context, attrs: AttributeSet?) : View(context, attrs) {
    private val paint = Paint()

    init {
        paint.color = Color.RED
    }

    override fun onDraw(canvas: Canvas) {
        canvas.drawCircle(width / 2f, height / 2f, width / 4f, paint)
    }

    fun changePaintColor(newColor: Int) {
        paint.color = newColor
        invalidate() // вызываем invalidate() для перерисовки Custom View
    }
}
```

####b.Метод `requestLayout()`

Если у нашего `View` были изменены размеры и/или позиция, необходимо вызвать метод `requestLayout()`, после которого последует вызов методов согласно жизненному циклу View, т.е. `onMeasure()` → `onLayout()` → `onDraw()`.

Пример использования:
```kotlin
class CustomView(context: Context, attrs: AttributeSet?) : View(context, attrs) {
    private var myWidth = 0
    private var myHeight = 0

    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {
        myWidth = MeasureSpec.getSize(widthMeasureSpec)
        myHeight = MeasureSpec.getSize(heightMeasureSpec)
        setMeasuredDimension(myWidth, myHeight)
    }

    override fun onLayout(changed: Boolean, left: Int, top: Int, right: Int, bottom: Int) {
        // располагаем элементы внутри Custom View
    }

    fun changeViewSize(newWidth: Int, newHeight: Int) {
        layoutParams.width = newWidth
        layoutParams.height = newHeight
        requestLayout() // вызываем requestLayout() для перерасположения Custom View
    }
}
```

Особенность применения этих методов заключаются в том, что частая перерисовка или пересчет размеров `View` может замедлить работу приложения. Поэтому лучше использовать эти методы только в случае необходимости. Например, если изменения внешнего вида `View` могут быть объединены в один вызов `invalidate()`, то лучше объединить их для уменьшения количества перерисовок.

### Q48a
### Атрибуты для Custom View

#### 1.Определяем атрибуты, которые будут доступны для этого `View`.

Для этого нужно создать `XML`-файл в папке `res/values` с расширением `attrs.xml` и описать там нужные атрибуты.

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <declare-styleable name="CustomView">
        <attr name="customText" format="string" />
        <attr name="customTextColor" format="color" />
    </declare-styleable>
</resources>
```

#### 2.В конструкторе View получаем атрибуты, переданные в XML, и сохраняем их в переменных класса.

```kotlin
class CustomView @JvmOverloads constructor(
    context: Context,
    attrs: AttributeSet? = null,
    defStyleAttr: Int = 0
) : View(context, attrs, defStyleAttr) {

    private var customText: String? = null
    private var customTextColor: Int = Color.BLACK

    init {
        val typedArray = context.obtainStyledAttributes(attrs, R.styleable.CustomView, defStyleAttr, 0)
        customText = typedArray.getString(R.styleable.CustomView_customText)
        customTextColor = typedArray.getColor(R.styleable.CustomView_customTextColor, Color.BLACK)
        typedArray.recycle()
    }

    // остальной код
}
```

Здесь мы получаем массив атрибутов `typedArray` из контекста с помощью метода c`ontext.obtainStyledAttributes()`, передавая ему параметры attrs и стиль `R.styleable.CustomView`. Затем мы извлекаем значение атрибута `customTextColor` из массива `typedArray` с помощью метода `typedArray.getColor()`. Вторым параметром мы передаем значение по умолчанию, которое будет использоваться, если атрибут не был задан. После извлечения значения мы обязательно вызываем метод `typedArray.recycle()`, чтобы освободить ресурсы.

[Содержание](#содержание)

### Q49a
## ⭐Библиотеки загрузки изображений
### COIL
![иллюстрация процесса](https://coil-kt.github.io/coil/logo.svg) 

Библиотека Coil получила своё название от сокращения "Coroutine Image Loader".

Библиотека написана на Kotlin и использует корутины. При этом она быстрее известной Glide. Пользоваться удобно и просто. 

#### 1.Как с ней работать?

В Android Studio прописываем зависимость в Gradle (проверяйте номер свежей версии).

```kotlin
dependencies {
    implementation 'io.coil-kt:coil:1.4.0' // старая ветка, больше не поддерживается
    implementation 'io.coil-kt:coil:2.2.2' // новая ветка разработки
}
```

#### 2.Загружаем в ImageView

Загружаем картинку из сети:

```kotlin

import coil.load

val imageView: ImageView = findViewById(R.id.imageView)
imageView.load("https://developer.alex.ru/android/images/android_cat.jpg")
```
По сути, библиотека делает функцию-расширение для ImageView, добавляя в компонент новые методы.

Можно загружать из ресурсов, файловой системы и т.д.
```kotlin
// Resource
imageView.load(R.drawable.dog)

// File
imageView.load(File("/path/to/city.jpg"))
```
Более сложный вариант с применением лямбды - используем заглушку и трансформацию в виде круга

```kotlin
imageView.load("https://developer.alex.ru/android/images/android_cat.jpg"){
    crossfade(true)
    crossfade(2000)
    placeholder(R.drawable.ic_action_cat)
    transformations(CircleCropTransformation())
```
Доступны также `GrayscaleTransformation (1.x)`, `BlurTransformation (1.x)`, `RoundedCornersTransformation`.

Например, картинка с закруглёнными углами (указываем величину радиуса):

```kotlin
transformations(RoundedCornersTransformation(40f))
```

### Получаем Drawable

Не всегда нам нужно сразу загружать картинку в ImageView, иногда нам нужно получить само изображение, которое потом можно где-то применить. В следующем примере мы получим картинку как Drawable и применим к кнопке как значок слева от текста.

```kotlin
val button: Button = findViewById(R.id.button)
button.setOnClickListener {
    val imageLoader = ImageLoader(this)
    val request: ImageRequest = ImageRequest.Builder(this)
        .data("https://developer.alex.ru/android/images/android_cat.jpg")
        .target { drawable ->
            button.setCompoundDrawablesRelativeWithIntrinsicBounds(
                drawable, null, null,
                null
            )
        }
        .build()

    imageLoader.enqueue(request)
}
```
Кроме асинхронного метода `enqueue()` есть ещё `execute()`, который можно использовать в корутинах.

### Поддержка других форматов

Библиотека также поддерживает форматы GIF и SVG, в этом случае нужно добавить дополнительные зависимости. 

### Q50a
### Glide

![иллюстрация процесса](https://www.devapp.it/wordpress/wp-content/uploads/2016/02/glide-logo.jpg) 

Библиотека Glide является ближайшим конкурентом другой популярной библиотеке Picasso и также предназначена для асинхронной подгрузки изображений из сети, ресурсов или файловой системы, их кэширования и отображения. Синтаксис и принцип работы очень схож. Во многом выбор определяется вкусом разработчика.

Но библиотека имеет дополнительную функциональность в виде поддержки анимированных GIF-файлов и видео.

#### 1.Как с ней работать?

В Android Studio прописываем зависимость в Gradle (проверяйте номер свежей версии).

```kotlin
implementation 'com.github.bumptech.glide:glide:4.14.2'
```
#### Базовый пример

Для простого примера достаточно указать три метода объекта Glide:

`with(Context context)` — передаём `Context`
`load(String imageUrl)` — указываем адрес картинки из интернета, ресурса, файла
`into(ImageView targetImageView)` — компонент `ImageView`, в котором должна отобразиться картинка

Разместим на экране активности кнопку и `ImageView`. Напишем пример загрузки изображения с заданного адреса.

```kotlin
package ru.alex.glide;

import android.os.Bundle;
import android.support.v7.app.AppCompatActivity;
import android.view.View;
import android.widget.ImageView;

import com.bumptech.glide.Glide;

public class MainActivity extends AppCompatActivity {

    private ImageView mImageView;
    private String mImageAddress =
            "http://developer.alexanderklimov.ru/android/images/android_cat.jpg";

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        mImageView = findViewById(R.id.imageView);
    }

    public void onClick(View view) {
        // Загружаем картинку
        Glide
                .with(this)
                .load(mImageAddress)
                .into(mImageView);
    }
}
```
Загружать можно не только из интернета, но и из ресурсов. Это может быть полезным при интенсивном использовании изображений больших размеров с различными эффектами.

```kotlin
public void onClick(View view) {

    int resourceId = R.mipmap.ic_launcher;

    Glide
            .with(this)
            .load(resourceId)
            .into(mImageView);
}
```

Загружаем из файла. В примере опущена проверка на существование файла. Но даже без проверки приложение не закроется с ошибкой, а просто ничего не загрузит.

```kotlin
File file = new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES), "cat.png");

Glide
      .with(this)
      .load(file)
      .into(mImageView);
```

Последний вариант связан с Uri. Это может быть адрес в интернете, а также адрес на ресурс.

```kotlin
int resourceId = R.mipmap.ic_launcher_round;

Uri uri = Uri.parse("android.resource://"  + this.getPackageName() + "/" + resourceId);

Glide
        .with(this)
        .load(uri)
        .into(mImageView);
```

### Q51a
### Picasso
![иллюстрация процесса](https://koenig-media.raywenderlich.com/uploads/2019/06/Picasso-feature.png) 

Предназначенная для асинхронной подгрузки изображений из сети, ресурсов или файловой системы, их кэширования и отображения.

#### 1.Как с ней работать?
В Android Studio прописываем зависимость в Gradle (проверяйте номер свежей версии).

```kotlin
dependencies {
    implementation 'com.squareup.picasso:picasso:2.5.2'
}
```

Вот как просто загрузить картинку из сети:

```kotlin
Picasso.with(context)
    .load(url)
    .placeholder(R.drawable.user_placeholder)
    .error(R.drawable.user_placeholder_error)
    .into(imageView);
```

Вы указываете адрес картинки (url), заглушку (placeholder), заглушку для ошибки после трёх неудачных попыток загрузки (error) и в методе into() указываете компонент ImageView, в который загружаете изображение.

При загрузке картинка кэшируется и при повторном запросе на скачивание библиотека может достать картинку из кэша, а не скачивать из интернета, что ускоряет работу приложения. Если кэш будет переполнен или удалён пользователем, то картина снова скачается из сети. Очень удобно.

Если вы храните большие картинки в ресурсах или на внешнем накопителе, то рекомендуется использовать отдельный процесс для загрузки. Библиотека уже настроена на работу в асинхронном режиме, поэтому вы можете использовать её и в этих случаях.

```kotlin
// из ресурсов
Picasso.with(context).load(R.drawable.landing_screen).into(imageView1);
// из внешнего накопителя
Picasso.with(context).load(new File(...)).into(imageView2);
```
Не забывайте про метод библиотеки fit(), который уменьшает размер картинки перед размещением в ImageView. Это полезно для экономии ресурсов, если вам в реальности нужна маленькая картинка, а не оригинал.

### Трансформация
У библиотеки есть специальный метод transform() для манипуляций с изображениями. Вам нужно создать собственную реализацию и передать её в метод.

Сначала создаётся отдельный класс с интерфейсом Transformation, который требует реализовать два метода transform() и key().

```java
package ru.alex.testapplication;

import android.graphics.Bitmap;

import com.squareup.picasso.Transformation;

public class CropSquareTransformation implements Transformation {
    @Override public Bitmap transform(Bitmap source) {
        int size = Math.min(source.getWidth(), source.getHeight());
        int x = (source.getWidth() - size) / 2;
        int y = (source.getHeight() - size) / 2;
        Bitmap result = Bitmap.createBitmap(source, x, y, size, size);
        if (result != source) {
            source.recycle();
        }
        return result;
    }

    @Override public String key() { return "square()"; }
}

```

Для наглядности разместим два компонента ImageView и посмотрим на результат после нажатия на кнопку.

```java
public class MainActivity extends ActionBarActivity {

    private ImageView mDrawableTransformedImage;
    private ImageView mDrawableTransformedImage2;

    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setContentView(R.layout.activity_main);

        mDrawableTransformedImage = (ImageView) findViewById(R.id.imageView);
        mDrawableTransformedImage2 = (ImageView) findViewById(R.id.imageView2);
    }
    
    public void onClick(View v) {

        Picasso.with(this)
                .load(R.drawable.cat_bottom)
                .transform(new CropSquareTransformation())
                .into(mDrawableTransformedImage);

        Picasso.with(this)
                .load(R.drawable.cat_bottom)
                //.transform(new CropSquareTransformation())
                .into(mDrawableTransformedImage2);
    }
} 
```
![иллюстрация процесса](https://developer.alexanderklimov.ru/android/library/picasso1.png) 


Другой пример трансформации - перекраска изображения.
![иллюстрация процесса](https://developer.alexanderklimov.ru/android/library/picasso2.png)

#### Круглый аватар

Ещё один пример, позволяющий создавать круглые картинки, которые можно использовать в качестве аватаров.

![иллюстрация процесса](https://developer.alexanderklimov.ru/android/library/picasso4.png)
[Содержание](#содержание)

# Дополнительные вопросы
### Что такое Bundle?
-класс, реализующий ассоциативный массив, т.е. хранящий пары ключ-значение. Имеет get() и put() методы для примитивов, строк и объектов, которые реализуют интерфейсы Parcelable и Serializable. Bundle используется для передачи данных между базовыми компонентами. Также может использоваться для сохранения состояния Activity. Имеет ограничение по возможности хранения данных (1 мегабайт).
