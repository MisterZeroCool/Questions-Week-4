# Questions-Week-4
Какие типы bundle вы знаете?
Что такое nuthing?
# Cicerone

### Что такое и для чего используется?
Это библиотека для простой навигации в Андроид приложении. 

Для осуществления переходов между Activity, переключения Fragment’ов или смены View внутри контейнера 

1.не обойтись без зависимости от Context’a, который не хочется передавать в слой логики, связывая тем самым его с платформой, усложняя тестирование и рискуя получить утечки памяти (если забыть очистить ссылку);

2.надо учитывать жизненный цикл контейнера (например, java.lang.IllegalStateException: Can not perform this action after onSaveInstanceState у Fragment’ов).

Поэтому и появилось решение, реализованное в Cicerone.
Cтруктура.

<p align="center">
  <img src="https://habrastorage.org/r/w1560/files/d1a/242/349/d1a2423490a24dc28e9c7e2baccdd5bf.png" alt="Preview">
</p>

На схеме есть четыре сущности:

`Command` – это простейшая команда перехода, которую выполняет Navigator.
`Navigator` – непосредственная реализация «переключения экранов» внутри контейнера.
`Router` – это класс, который превращает высокоуровневые вызовы навигации презентера в набор Command.
`CommandBuffer` – отвечает за сохранность вызванных команд навигации, если в момент их вызова нет возможности осуществить переход.

Любую карту переходов (даже достаточно сложную) можно реализовать, используя четыре базовых перехода, комбинируя которые, мы получим необходимое поведение.

<h3 align="center"><strong>Forward</strong></h3>
<p align="center">
  <img src="https://habrastorage.org/files/9de/c5e/3e1/9dec5e3e1d664c3b8ee6f5973f9a1474.png" alt="Preview">
</p>

`Forward(String screenKey, Object transitionData)` – команда, которая осуществляет переход на новый экран, добавляя его в текущую цепочку экранов.

`screenKey` – уникальный ключ, для каждого экрана.
`transitionData` – данные, необходимые новому экрану.

Буквой R обозначен корневой экран, его особенность только в том, что при выходе с этого экрана, мы выйдем из приложения.

<h3 align="center"><strong>Back</strong></h3>
<p align="center">
  <img src="https://habrastorage.org/r/w1560/files/372/8e1/97d/3728e197d3344708adcc003bfc9f106d.png" alt="Preview">
</p>

Back() – команда, удаляющая последний активный экран из цепочки, и возвращающая на предыдущий. При вызове на корневом экране ожидается выход из приложения.

<h3 align="center"><strong>BackTo</strong></h3>
<p align="center">
  <img src="https://habrastorage.org/r/w1560/files/715/8d5/392/7158d5392e6840e9b4ff42c2f8512742.png" alt="Preview">
</p>

`BackTo(String screenKey)` – команда, позволяющая вернуться на любой из экранов в цепочке, достаточно указать его ключ. Если в цепочке два экрана с одинаковым ключом, то выбран будет последний (самый «правый»).

Стоит отметить, что если указанный экран не найден, либо в параметр ключа передать null, то будет осуществлен переход на корневой экран.

На практике эта команда очень удобна. Например, для авторизации: два экрана. Телефон -> СМС, а потом выход на тот, с которого была запущена авторизация.

<h3 align="center"><strong>Replace</strong></h3>
<p align="center">
  <img src="https://habrastorage.org/files/56b/f49/737/56bf49737c9f495c8f51a26766b79823.png" alt="Preview">
</p>

Replace(String screenKey, Object transitionData) – команда, заменяющая активный экран на новый.
Кто-то может возразить, что этого результата удастся достичь, вызвав подряд команды Back и Forward, но тогда на корневом экране мы выйдем из приложения!

Вот и всё! Этих четырёх команд на практике достаточно для построения любых переходов. Но есть ещё одна команда, которая не относится к навигации, однако очень полезна на практике.

<h3 align="center"><strong>Message</strong></h3>
<p align="center">
  <img src="https://habrastorage.org/r/w1560/files/ff9/a22/9b3/ff9a229b3fbd418c8af545e5157be464.png" alt="Preview">
</p>

`SystemMessage(String message)` – команда, отображающая системное сообщение (Alert, Toast, Snack и т. д.).

Иногда необходимо выйти с экрана и показать сообщение пользователю. Например, что мы сохранили сделанные изменения. Но экран, на который мы возвращаемся, не должен знать о чужой логике, и поэтому мы вынесли показ таких сообщений в отдельную команду. Это очень удобно!

### Что такое Navigator?
Команды сами по себе не реализуют переключение экранов, а только описывают эти переходы. За их выполнение отвечает Navigator.

```kotlin
interface Navigator {
  fun applyCommand(command: Command)
}
```

В зависимости от задачи, Navigator будет реализован по-разному, но он всегда будет там, где находится контейнер для переключаемых экранов.

- В Activity для переключения Fragment’ов.
- Во Fragment’е для переключения вложенных (child) Fragment’ов.

Так как в подавляющем большинстве Андроид приложений навигация опирается на переключение Fragment’ов внутри Activity, чтобы не писать однотипный код, в библиотеке уже есть готовый FragmentNavigator (и SupportFragmentNavigator для SupportFragment’ов), реализующий представленные команды.

Достаточно:

1) передать в конструктор ID контейнера и FragmentManager;
2) реализовать методы выхода из приложения и отображения системного сообщения;
3) реализовать создание Fragment’ов по screenKey.

### Что такое Router?
Комбинируя команды, можно реализовать любой переход. Именно этой задачей и занимается Router.

Один Router связан только с одним Navigator’ом в любой момент времени.

Например, если стоит задача по некоторому событию в презентере:

1) скинуть всю цепочку до корневого экрана;
2) заменить корневой экран на новый;
3) и еще показать системное сообщение;

то в Router добавляется метод, который передает последовательность из трёх команд на выполнение в CommandBuffer

```kotlin
fun navigateToNewRootWithMessage(screenKey: String, data: Any?, message: String) {
    executeCommand(BackTo(null))
    executeCommand(Replace(screenKey, data))
    executeCommand(SystemMessage(screenKey, data))
}
```

В библиотеке есть готовый Router, используемый по-умолчанию, с самыми необходимыми переходами, но как и с навигатором, никто не запрещает создать свою реализацию.

`navigateTo()` – переход на новый экран.
`newScreenChain()` – сброс цепочки до корневого экрана и открытие одного нового.
`newRootScreen()` – сброс цепочки и замена корневого экрана.
`replaceScreen()` – замена текущего экрана.
`backTo()` – возврат на любой экран в цепочке.
`exit()` – выход с экрана.
`exitWithMessage()` – выход с экрана + отображение сообщения.
`showSystemMessage()` – отображение системного сообщения.

### Что такое CommandBuffer?
CommandBuffer – класс, который отвечает за доставку команд навигации Navigator’у. Логично, что ссылка на экземпляр навигатора хранится в CommandBuffer’е. Она попадает туда через интерфейс NavigatorHolder:

```kotlin
interface NavigatorHolder {
    fun setNavigator(navigator: Navigator)
    fun removeNavigator()
}
```
Кроме того, если в CommandBuffer поступят команды, а в данный момент он не содержит Navigator’а, то они сохранятся в очереди, и будут выполнены сразу при установке нового Navigator’а. Именно благодаря CommandBuffer’у удалось решить все проблемы жизненного цикла.

Конкретный пример для Activity:

```kotlin
override fun onResume() {
  super.onResume()
  SampleApplication.INSTANCE.navigatorHolder.setNavigator(navigator)
}

override fun onPause() {
  SampleApplication.INSTANCE.navigatorHolder.removeNavigator()
  super.onPause()
}
```
Почему именно onResume и onPause? Для безопасной транзакции Fragment’ов и отображения системного сообщения в виде алерта.






